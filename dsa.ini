Week 1: Sliding Window
Core Concept:
Sliding Window uses two pointers (start and end) to represent a contiguous range within an array or string. By dynamically adjusting the window and maintaining state (like counts or sums), it processes subarrays or substrings efficiently in O(n) time, avoiding nested loops.
When to Use:
Use when the problem involves finding or optimizing contiguous subarrays or substrings with constraints on length, sum, or distinct elements. Common in "longest", "shortest", or "at most K" type substring/subarray problems.
Top 10 Problem Set:
1.	Maximum Sum Subarray of Size K — Slide a fixed-size window, update sum by adding new and removing oldest element.
2.	Longest Substring Without Repeating Characters — Expand window until duplicate found, then shrink from left to maintain uniqueness.
3.	Longest Substring with At Most K Distinct Characters — Use hashmap to track counts, expand/shrink to keep ≤ K distinct chars.
4.	Minimum Window Substring — Use frequency maps and two pointers to find smallest substring containing all target chars.
5.	Permutation in String — Sliding window frequency comparison to detect permutation presence.
6.	Fruit Into Baskets — Longest substring with ≤ 2 distinct chars using sliding window + hashmap.
7.	Find All Anagrams in a String — Fixed window with frequency counts; record indices matching target anagram.
8.	Longest Repeating Character Replacement — Track max frequency char; replace ≤ k chars; slide window to maximize length.
9.	Sliding Window Maximum — Use deque to maintain max element indices in window efficiently.
10.	Subarrays with K Different Integers — Count subarrays with ≤ K and ≤ K-1 distinct; difference gives exact K.

Week 2: Two Pointers
Core Concept:
Two Pointers use two indices moving from opposite ends or specific positions to process elements efficiently, often reducing O(n²) to O(n).
When to Use:
For pair/triplet sum problems, removing duplicates in sorted arrays, or trapping rain water problems.
Top 10 Problem Set:
1.	Two Sum II (Sorted) — Move two pointers inward based on sum comparison.
2.	3Sum — Fix one element; use two pointers to find pairs summing to negative fixed element.
3.	Container With Most Water — Move smaller pointer inward to find max area between lines.
4.	Remove Duplicates from Sorted Array — Use slow/fast pointers to overwrite duplicates in-place.
5.	Trapping Rain Water — Two pointers track max height boundaries from both ends.
6.	Squares of a Sorted Array — Use two pointers from ends to fill result in descending order.
7.	Merge Sorted Array — Two pointers from ends to merge in place.
8.	Remove Element — Two pointers to overwrite unwanted elements.
9.	Valid Palindrome II — Two pointers check with one allowed skip.
10.	Reverse String II — Two pointers to reverse substrings in place.
 
Week 3: Prefix Sum / Difference Arrays
Core Concept:
Prefix sums precompute cumulative totals for efficient range sum queries. Difference arrays track incremental updates compactly.
When to Use:
Subarray sums, range queries, incremental updates, overlapping intervals.
Top 10 Problem Set:
1.	Subarray Sum Equals K — Prefix sums + hashmap to count subarrays summing to K.
2.	Maximum Size Subarray Sum Equals K — Track earliest prefix sums to find longest subarray.
3.	Range Sum Query - Immutable — Precompute prefix sums for constant-time queries.
4.	Car Pooling — Use difference array to track passenger changes.
5.	Matrix Block Sum — 2D prefix sums for fast block sum queries.
6.	Continuous Subarray Sum — Prefix sums mod k to detect valid subarrays.
7.	Count Subarrays with Sum Equals K — Similar to subarray sum using prefix sum + hashmap.
8.	Find Pivot Index — Prefix sums to find equilibrium index.
9.	Range Addition — Difference array for efficient range increments.
10.	Ways to Split Array Into Three Subarrays — Prefix sums for quick subarray sum checks.

 
Week 4: Hashing / Maps / Sets
Core Concept:
Use hash maps or sets for O(1) average lookup to track frequencies, detect duplicates, or group items efficiently.
When to Use:
Frequency counting, grouping anagrams, complement lookups, detecting duplicates/isomorphic patterns.
Top 10 Problem Set:
1.	Group Anagrams — Use sorted string or char count as hashmap key to group.
2.	Longest Consecutive Sequence — Hash set to detect starts of consecutive sequences.
3.	Two Sum — Hash map complement lookup for pairs summing to target.
4.	Isomorphic Strings — Two hash maps to verify char mappings between strings.
5.	Subarray Sum Equals K (hash variant) — Prefix sums + hashmap to count subarrays.
6.	Happy Number — Detect cycle using hash set.
7.	Contains Duplicate — Hash set to check duplicates.
8.	Valid Anagram — Hash maps to compare char counts.
9.	Find All Anagrams in a String — Hash maps and sliding window to find anagrams.
10.	Longest Substring Without Repeating Characters — Hash map to track last occurrence positions.

 
Week 5: Linked Lists
Core Concept:
Manipulate pointers carefully for traversal, insertion, deletion, and cycle detection in singly or doubly linked lists.
When to Use:
Pointer re-linking, cycle detection, reversing lists, node position operations.
Top 10 Problem Set:
1.	Reverse Linked List — Iteratively or recursively reverse pointers.
2.	Merge Two Sorted Lists — Merge like merge step in merge sort.
3.	Detect Cycle in Linked List — Floyd’s slow/fast pointers.
4.	Remove N-th Node From End — Two pointers spaced n apart locate node to remove.
5.	Reorder List — Split, reverse second half, merge alternately.
6.	Linked List Cycle II — Find cycle start node.
7.	Palindrome Linked List — Reverse second half, compare halves.
8.	Intersection of Two Linked Lists — Two pointers to find intersection.
9.	Add Two Numbers — Digit-by-digit addition with carry.
10.	Copy List with Random Pointer — Hashmap or node interleaving copy.

 
Week 6: Stacks & Monotonic Stack
Core Concept:
Use stack to track previous/next greater/smaller elements, validate nested structures, or evaluate postfix expressions.
When to Use:
Parentheses matching, next greater element queries, min stacks, sliding window max, expression evaluation.
Top 10 Problem Set:
1.	Valid Parentheses — Stack to match brackets.
2.	Daily Temperatures — Monotonic stack for next warmer day.
3.	Min Stack — Track current minimum with values.
4.	Sliding Window Maximum — Monotonic deque for max in window.
5.	Evaluate Reverse Polish Notation — Stack for postfix eval.
6.	Next Greater Element I — Stack to find next greater.
7.	Remove K Digits — Greedy stack for smallest number.
8.	Largest Rectangle in Histogram — Monotonic stack for nearest smaller bars.
9.	Score of Parentheses — Stack to evaluate scores by depth.
10.	Basic Calculator II — Stack eval without parentheses.

 
Week 7: Trees (BFS/DFS + Properties)
Core Concept:
Traverse trees using DFS/BFS for hierarchical data. Validate BSTs, calculate heights or diameters.
When to Use:
Tree traversal, lowest common ancestor, validating BSTs, diameter, serialization/deserialization.
Top 10 Problem Set:
1.	Binary Tree Level Order Traversal — BFS queue level-wise.
2.	Lowest Common Ancestor of BST — BST property or recursion.
3.	Validate BST — Inorder check ascending or bounds.
4.	Diameter of Binary Tree — DFS max path lengths.
5.	Serialize and Deserialize Binary Tree — BFS/preorder with markers.
6.	Invert Binary Tree — Swap left/right children recursively.
7.	Path Sum — DFS root-to-leaf sum check.
8.	Binary Tree Maximum Path Sum — DFS max path sums via nodes.
9.	Balanced Binary Tree — DFS height check.
10.	Construct Binary Tree from Preorder and Inorder — Recursive rebuild.

 
Week 8: Backtracking
Core Concept:
Explore all choices recursively; prune invalid options; backtrack to try alternatives.
When to Use:
Permutations, combinations, constraint satisfaction, puzzles like N-Queens or Sudoku.
Top 10 Problem Set:
1.	Subsets — Recursively include/exclude elements.
2.	Permutations — Swap recursively to generate orders.
3.	Word Search — DFS with visited marking.
4.	N-Queens — Place queens row-wise, prune conflicts.
5.	Sudoku Solver — Backtrack with constraints.
6.	Combination Sum — Recursive candidate addition to sum.
7.	Letter Combinations of a Phone Number — Backtrack digit-to-letter mappings.
8.	Restore IP Addresses — Backtrack to split string into valid IP parts.
9.	Palindrome Partitioning — Backtrack palindrome substring checks.
10.	Generate Parentheses — Backtrack valid '(' and ')' sequences.

 
Week 9: Graphs (BFS/DFS/Topo Sort)
Core Concept:
Explore nodes/edges with BFS or DFS; detect cycles; perform topological sorts; find connected components/shortest paths.
When to Use:
Network traversal, cycle detection, ordering dependencies, shortest path, union-find.
Top 10 Problem Set:
1.	Number of Islands — BFS/DFS mark connected land.
2.	Clone Graph — DFS/BFS with hashmap copy.
3.	Course Schedule — Cycle detection/topological sort.
4.	Network Delay Time — Dijkstra’s shortest paths.
5.	Accounts Merge — Union-find or DFS merge emails.
6.	Graph Valid Tree — DFS connectivity & cycle check.
7.	Find Eventual Safe States — DFS with state to detect cycles.
8.	Minimum Height Trees — Remove leaves iteratively.
9.	Cheapest Flights Within K Stops — BFS or Bellman-Ford variant.
10.	Course Schedule II — Output topological order.

 
Week 10: Dynamic Programming
Core Concept:
Break problems into overlapping subproblems; store results to avoid recomputation and optimize exponential recursions.
When to Use:
Optimization on subsequences, counting ways, decision making with overlapping states.
Top 10 Problem Set:
1.	Climbing Stairs — Fibonacci recurrence for ways.
2.	House Robber — Choose rob or skip for max gain.
3.	Longest Palindromic Substring — Expand centers or DP table.
4.	Coin Change — Count ways or min coins DP.
5.	Decode Ways — Count decoding ways DP.
6.	Longest Increasing Subsequence — Track best subsequence ending at each index.
7.	Word Break — DP for segmentability.
8.	Maximum Product Subarray — Track max/min product at index.
9.	Edit Distance — DP minimal transformation.
10.	Partition Equal Subset Sum — Subset sum DP.

 
Week 11: Greedy
Core Concept:
Make locally optimal choices hoping for global optimum. Often involves sorting or linear scans.
When to Use:
Interval scheduling, resource allocation, jump games, optimization problems.
Top 10 Problem Set:
1.	Merge Intervals — Sort by start; merge overlaps.
2.	Non-overlapping Intervals — Sort by end; greedy picks.
3.	Jump Game — Track max reachable index greedily.
4.	Gas Station — Feasibility via cumulative sums.
5.	Task Scheduler — Schedule to minimize idle.
6.	Partition Labels — Greedy partitions by last occurrence.
7.	Lemonade Change — Greedy cash handling.
8.	Assign Cookies — Sort and assign smallest cookie greedily.
9.	Candy — Local adjustments to satisfy conditions.
10.	Minimum Number of Arrows to Burst Balloons — Sort by end; greedily pick arrows.

 
Week 12: Binary Search / Heaps / Misc
Core Concept:
Binary Search divides search space to find target efficiently in sorted or monotonic spaces. Heaps maintain min/max efficiently for priority queries.
When to Use:
Binary search on sorted/rotated arrays, monotonic function search, heaps for kth elements or merging sorted data.
Top 10 Problem Set:
1.	Search in Rotated Sorted Array — Modified binary search with rotation logic.
2.	Find Peak Element — Binary search comparing mid neighbors.
3.	Median of Two Sorted Arrays — Partition arrays for median.
4.	Capacity to Ship Packages Within D Days — Binary search on answer space.
5.	Kth Largest Element in a Stream — Min heap maintaining top k elements.
6.	Merge K Sorted Lists — Min heap to merge efficiently.
7.	Top K Frequent Elements — Heap to track top frequencies.
8.	Reorganize String — Heap to rearrange chars avoiding adjacents.
9.	Sliding Window Maximum — Deque and heap combined.
10.	Find K Closest Elements — Binary search for window position.

 
Week 13: Tries (Prefix Trees)
Core Concept:
Trie is a tree structure for strings enabling efficient prefix searches, autocomplete, and pattern matching.
When to Use:
Dictionary lookups, prefix matching, autocomplete systems, bitwise XOR problems.
Top 10 Problem Set:
1.	Implement Trie — Insert, search, delete strings.
2.	Word Search II — Backtracking with Trie pruning.
3.	Replace Words — Trie to find shortest root replacements.
4.	Autocomplete System — Trie + priority queue suggestions.
5.	Maximum XOR of Two Numbers in an Array — Bitwise Trie for fast XOR.
6.	Prefix and Suffix Search — Trie with suffix links.
7.	Concatenated Words — Trie to check word concatenations.
8.	Longest Word in Dictionary — Trie to verify constructions.
9.	Add and Search Word - Data Structure Design — Trie with '.' wildcard support.
10.	Design Search Autocomplete System — Trie with top-k frequency.

 
Week 14: Bit Manipulation
Core Concept:
Use bits to represent and manipulate data compactly and efficiently. Includes toggling, masking, XOR, shifts.
When to Use:
Counting bits, parity checks, subsets, unique element detection, XOR-related problems.
Top 10 Problem Set:
1.	Single Number — XOR cancels duplicates.
2.	Number of 1 Bits — Bitwise AND and shifts to count bits.
3.	Counting Bits — DP or built-in count bits.
4.	Maximum XOR of Two Numbers in an Array — Trie or greedy bit checks.
5.	Subsets Using Bitmasking — Bitmasks to generate subsets.
6.	Power of Two — Check single bit set.
7.	Reverse Bits — Bit shifting and masking.
8.	Sum of Two Integers — Bitwise sum using XOR and AND carry.
9.	Missing Number — XOR all indices and nums.
10.	Convert Number to Binary String — Bitwise manipulation.

